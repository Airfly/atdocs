# Implement a Doorbell Button

## This lesson teaches you to

1.  Connect hardware to GPIO
2.  Initialize a peripheral driver
3.  Manage peripheral connections

## Try it out

*   [Doorbell sample app](https://github.com/androidthings/doorbell)

A doorbell isn't much to speak of without a button for visitors to press and announce their presence at the door.

In this lesson, you will learn to connect a pushbutton to a GPIO input, initialize it using Peripheral I/O, and listen for state changes on that input.

## Connect the button

* * *

Using a breadboard, connect a pushbutton switch to the appropriate GPIO port on your board. To connect the button to your board:

1.  Connect one side of the button to the chosen GPIO input pin, and the other side to ground.
2.  Connect the same GPIO input pin to +3.3V through a pull-up resistor.

For this lesson, the following GPIO pins are assumed on each board:

<table style="width:360px;">

<tbody>

<tr>

<th width="50%">Board</th>

<th>Input Signal</th>

</tr>

<tr>

<td>

[NXP Pico i.MX7D](https://developer.android.google.cn/things/hardware/imx7d-pico-io.html)

</td>

<td>GPIO_39</td>

</tr>

<tr>

<td>

[Raspberry Pi](https://developer.android.google.cn/things/hardware/raspberrypi-io.html)

</td>

<td>BCM21</td>

</tr>

</tbody>

</table>

![""](https://developer.android.google.cn/things/images/doorbell-button-wiring.png)

<aside class="note">**Note:** <span>See [Hardware 101](https://developer.android.google.cn/things/hardware/hardware-101.html) for more detail on connecting input and output components.</span></aside>

## Capture button press events

* * *

The `Button` peripheral driver handles the low-level logic of listening for GPIO state changes. It also debounces the input port by default, to avoid multiple trigger events from a single button press. To add the button driver to your app:

1.  Add a button peripheral to your app project by connecting it to an available GPIO port.
2.  Add the button driver dependency to your app-level `build.gradle` file:

        dependencies {    ...    compile 'com.google.android.things.contrib:driver-button:0.3'}

3.  Initialize a `ButtonInputDriver` with the connected GPIO port name, and the appropriate logic state indicating when the button is physically pressed.

4.  By using a `ButtonInputDriver` instead of a `Button`, you are associating Android key press/release events with the button connected to the GPIO. Specify which `KeyEvent` key code will be generated in the `ButtonInputDriver` constructor.
5.  Capture the key up or down events, as if they were being generated by a keyboard, by overriding the `Activity.onKeyUp` or `onKeyDown` method:

        public class DoorbellActivity extends Activity {    /*     * Driver for the doorbell button;     */    private ButtonInputDriver mButton;    /**     * The GPIO pin to activate for button presses.     */    private final String BUTTON_GPIO_PIN = ...;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Log.d(TAG, "Doorbell Activity created.");        ...        // Initialize the doorbell button driver        try {            mButton = new ButtonInputDriver(BUTTON_GPIO_PIN,                Button.LogicState.PRESSED_WHEN_LOW, KeyEvent.KEYCODE_ENTER); // The keycode to send        } catch (IOException e) {            Log.e(TAG, "button driver error", e);        }    }    /**     * Override key event callbacks.     */    @Override    public boolean onKeyUp(int keyCode, KeyEvent event) {        if (keyCode == KeyEvent.KEYCODE_ENTER) {            // Doorbell rang!            Log.d(TAG, "button pressed");            return true;        }        return super.onKeyUp(keyCode, event);    }}

## Manage the connection

* * *

You should manage the peripheral connection according to the application component lifecycle. You already initialized the `ButtonInputDriver` component when the parent Activity was created. Now close the connection when the Activity is stopped or destroyed.

    public class DoorbellActivity extends Activity {    ...    private ButtonInputDriver mButton;    @Override    protected void onDestroy() {        super.onDestroy();        ...        try {            mButton.close();        } catch (IOException e) {            Log.e(TAG, "button driver error", e);        }    }}

