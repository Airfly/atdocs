# Implement a Doorbell Button

##实现一个门铃按钮

## This lesson teaches you to

##本节课你将学到

1.  Connect hardware to GPIO

1. 将硬件连接到 GPIO
2. Initialize a peripheral driver


2. 初始化一个外部设备驱动
3. Manage peripheral connections


3. 管理外部设备的连接

## Try it out

##试试看

*   [Doorbell sample app](https://github.com/androidthings/doorbell)
*   [例子工程](https://github.com/androidthings/doorbell)

A doorbell isn't much to speak of without a button for visitors to press and announce their presence at the door.

一个门铃没有访客可以按的按钮然后没有出现在门上是不值得一提的。

In this lesson, you will learn to connect a pushbutton to a GPIO input, initialize it using Peripheral I/O, and listen for state changes on that input.

通过这节课，你将学会将一个开关连接到 GPIO 的输入端口，使用外部设备初始化它，并且监听输入时的状态变化。

## Connect the button

##连接开关

* * *

Using a breadboard, connect a pushbutton switch to the appropriate GPIO port on your board. To connect the button to your board:

将开关按钮连接在电路板中合适的 GPIO 接口上。连接开关到你的电路板：

1.  Connect one side of the button to the chosen GPIO input pin, and the other side to ground.

1. 将开关的一端连接到你选择的 GPIO 的输入引脚，另一个端不用管。


2. Connect the same GPIO input pin to +3.3V through a pull-up resistor.


2. 将一个 +3.3V 的上拉电阻连接到上面的输入引脚。

For this lesson, the following GPIO pins are assumed on each board:

本节中，在电路板上添加以下 GPIO 引脚：

<table style="width:360px;">

<tbody>

<tr>

<th width="50%">Board</th>

<th>Input Signal</th>

</tr>

<tr>

<td>

[NXP Pico i.MX7D](https://developer.android.google.cn/things/hardware/imx7d-pico-io.html)

</td>

<td>GPIO_39</td>

</tr>

<tr>

<td>

[Raspberry Pi](https://developer.android.google.cn/things/hardware/raspberrypi-io.html)

</td>

<td>BCM21</td>

</tr>

</tbody>

</table>

![""](https://developer.android.google.cn/things/images/doorbell-button-wiring.png)

<aside class="note">**Note:** <span>See [Hardware 101](https://developer.android.google.cn/things/hardware/hardware-101.html) for more detail on connecting input and output components.</span></aside>

<aside class="note">**Note:** <span> 查看  [Hardware 101](https://developer.android.google.cn/things/hardware/hardware-101.html)  了解连接输入/输出元器件更详细的信息。</span></aside>

## Capture button press events

##捕获按钮按下事件

* * *

The `Button` peripheral driver handles the low-level logic of listening for GPIO state changes. It also debounces the input port by default, to avoid multiple trigger events from a single button press. To add the button driver to your app:

`Button` 外设驱动处理对 GPIO 状态更改的低级逻辑。他也默认反弹输入端口，用于避免单次按压会重复引发事件。在你的应用中添加一个按钮：

1.  Add a button peripheral to your app project by connecting it to an available GPIO port.

1. 通过将按钮连接到一个可用的 GPIO 接口，为你的工程添加一个按钮外设。


2. Add the button driver dependency to your app-level `build.gradle` file:


2. 添加按钮驱动依赖到你的应用下的`build.gradle`文件中：

```
  dependencies {    ...    compile 'com.google.android.things.contrib:driver-button:0.3'}
```

3. Initialize a `ButtonInputDriver` with the connected GPIO port name, and the appropriate logic state indicating when the button is physically pressed.


3. 将连接的 GPIO 的端口初始化为一个 `ButtonInputDriver`，并根据按钮的按压显示合适的逻辑状态。
4. By using a `ButtonInputDriver` instead of a `Button`, you are associating Android key press/release events with the button connected to the GPIO. Specify which `KeyEvent` key code will be generated in the `ButtonInputDriver` constructor.


4. 使用 `ButtonInputDriver`  代替 `Button`，将 Andoird 按键按下/松开事件和连接在 GPIO 的按钮相关联。在 `ButtonInputDriver` 的构造函数中指定 `keyEvent` 键码值。


5. Capture the key up or down events, as if they were being generated by a keyboard, by overriding the `Activity.onKeyUp` or `onKeyDown` method:


5. 通过重写 `Activity.onKeyUp` 或者 `onKeyDown` 来捕捉由键盘触发的按钮按下或释放事件：

```
  public class DoorbellActivity extends Activity {    /*     * Driver for the doorbell button;     */    private ButtonInputDriver mButton;    /**     * The GPIO pin to activate for button presses.     */    private final String BUTTON_GPIO_PIN = ...;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Log.d(TAG, "Doorbell Activity created.");        ...        // Initialize the doorbell button driver        try {            mButton = new ButtonInputDriver(BUTTON_GPIO_PIN,                Button.LogicState.PRESSED_WHEN_LOW, KeyEvent.KEYCODE_ENTER); // The keycode to send        } catch (IOException e) {            Log.e(TAG, "button driver error", e);        }    }    /**     * Override key event callbacks.     */    @Override    public boolean onKeyUp(int keyCode, KeyEvent event) {        if (keyCode == KeyEvent.KEYCODE_ENTER) {            // Doorbell rang!            Log.d(TAG, "button pressed");            return true;        }        return super.onKeyUp(keyCode, event);    }}
```

## Manage the connection

## 管理连接

* * *

You should manage the peripheral connection according to the application component lifecycle. You already initialized the `ButtonInputDriver` component when the parent Activity was created. Now close the connection when the Activity is stopped or destroyed.

你应该根据应用程序组件的生命周期来管理外设的连接。在 Activity 被创建的时候你已经初始化了 `ButtonInputDriver` 。当 Activity 处于暂停或销毁的生命状态时关闭连接。

    public class DoorbellActivity extends Activity {    ...    private ButtonInputDriver mButton;    @Override    protected void onDestroy() {        super.onDestroy();        ...        try {            mButton.close();        } catch (IOException e) {            Log.e(TAG, "button driver error", e);        }    }}

